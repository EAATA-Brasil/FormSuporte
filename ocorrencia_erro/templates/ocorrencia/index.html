{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'ocorrencia/css/styles.css' %}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>
<body>

    <table id="data-table" class="table">
        <thead>
            <tr style="background-color: #0459B5;">
                {% include 'ocorrencia/components/lineHead.html' with name='id' ID="codigo_externo"%}
                {% include 'ocorrencia/components/lineHead.html' with name='data' ID="data"%}
                {% include 'ocorrencia/components/lineHead.html' with name='Técnico' ID="technical"%}
                {% include 'ocorrencia/components/lineHead.html' with name='país' ID="country"%}
                {% include 'ocorrencia/components/lineHead.html' with name='dispositivo' ID="device"%}
                {% include 'ocorrencia/components/lineHead.html' with name='area' ID="area"%}
                {% include 'ocorrencia/components/lineHead.html' with name='marca' ID="brand"%}
                {% include 'ocorrencia/components/lineHead.html' with name='modelo' ID="model"%}
                {% include 'ocorrencia/components/lineHead.html' with name='Detalhes' ID="problem_detected" checbox='false'%}
                {% include 'ocorrencia/components/lineHead.html' with name='status' ID="status"%}
                {% include 'ocorrencia/components/lineHead.html' with name='prazo' ID="deadline"%}
                {% if has_full_permission%}
                    {% include 'ocorrencia/components/lineHead.html' with name='responsável' ID="responsible"%}
                {%endif%}
                {% include 'ocorrencia/components/lineHead.html' with name='finalizado' ID="finished"%}
                {% include 'ocorrencia/components/lineHead.html' with name='Feedback Technical' ID="feedback_technical" checbox='false'%}
            </tr>
            
        </thead>
        <tbody id="table-body">
        {# O corpo da tabela será preenchido via AJAX #}
        </tbody>
    </table>
    
    <div id="paginate">
        <span class="button-paginator" id="last">Voltar</span>
        <span id="num_pages">
            
        </span>
        <span class="button-paginator" id="next">Avançar</span>
    </div>
    <a href="{% url 'subir_ocorrencia' %}" style="padding: 0.6rem 1.2rem;
        font-size: 1rem;
        border: none;
        border-radius: 0.3rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
        text-decoration: none;
        display: inline-block;
        background-color: #157347;
        color: var(--light);">
        <i class="fas fa-plus"></i> Nova Ocorrência
    </a>
    {%if has_full_permission%}
        <a href="{% url 'criar_usuario' %}" style="padding: 0.6rem 1.2rem;
        font-size: 1rem;
        border: none;
        border-radius: 0.3rem;
        cursor: pointer;
        transition: background-color 0.2s ease;
        text-decoration: none;
        display: inline-block;
        background-color:rgb(17, 90, 226);
        color: var(--light);">
            <i class="fas fa-plus"></i> Criar novo responsável
        </a>
    {%endif%}
    {%if has_full_permission%}
    <footer>
        <div id="ocorrencias-panel">
            <label for="responsavel-select">Selecionar responsável:</label>
            <div id="selector-and-info">
                <select id="responsavel-select">
                    <option value="">-- Escolha --</option>
                </select>

                <div id="ocorrencias-info" style="display: none;">
                    <strong>Total de ocorrências: <span id="total-ocorrencias">0</span></strong>
                    <ul id="status-percentuais"></ul>
                </div>
            </div>
        </div>
    </footer>
    {%endif%}
<script>
    function getCookie(name) { 
             if (document.cookie && document.cookie !== "") {
                const cookies = document.cookie.split(";");
                for (let i = 0; i < cookies.length; i++) {
                    let cookie = cookies[i].trim();
                    if (cookie.startsWith(name + "=")) {
                        return decodeURIComponent(cookie.substring(name.length + 1));
                    }
                }
            }
            return null;
        }
    if("{{has_full_permission}}" == "True"){
        const ocorrenciasData = {{ ocorrencias_json | safe }};
        
        const select = document.getElementById('responsavel-select');
        const infoDiv = document.getElementById('ocorrencias-info');
        const totalSpan = document.getElementById('total-ocorrencias');
        const statusList = document.getElementById('status-percentuais');
        
        // Preenche <select> com nomes dos responsáveis
        Object.keys(ocorrenciasData).forEach(nome => {
          const opt = document.createElement('option');
          opt.value = nome;
          opt.textContent = nome;
          select.appendChild(opt);
        });
        
        select.addEventListener('change', () => {
          const responsavel = select.value;
        
          if (!responsavel || !ocorrenciasData[responsavel]) {
            infoDiv.style.display = 'none';
            return;
          }
        
          const stats = ocorrenciasData[responsavel];
          const total = Object.values(stats).reduce((a, b) => a + b, 0);
        
          totalSpan.textContent = total;
          statusList.innerHTML = '';
        
          Object.entries(stats).forEach(([status, qtd]) => {
            const percent = total > 0 ? ((qtd / total) * 100).toFixed(1) : 0;
            const li = document.createElement('li');
            li.textContent = `${status}: ${qtd} (${percent}%)`;
        
            const statusLower = status.toLowerCase();
        
            if (statusLower.includes("atrasado")) {
              li.classList.add("status-atrasado");
            } else if (statusLower.includes("concluido") || statusLower.includes("concluído")) {
              li.classList.add("status-concluido");
            } else if (statusLower.includes("progresso")) {
              li.classList.add("status-progresso");
            } else if (statusLower.includes("requisitado")) {
              li.classList.add("status-requisitado");
            }
        
            statusList.appendChild(li);
          });
        
          infoDiv.style.display = 'block';
        });
    }
    function deleteFile(fileId, fileName, record) {
        if (confirm(`Deseja realmente deletar o arquivo "${fileName}"?`)) {
            const formData = new FormData();
            formData.append('action', 'deletar');
            formData.append('file', fileId);

            fetch('{% url "update_ocorrencia/" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')  // importante para Django
                },
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    applyFiltersAndSort();
                    Swal.close();
                    setTimeout(async () => {
                    try {
                        console.log(record)
                        const response = await fetch(`/ocorrencia/get_record/${record.id}`);
                        const updatedRecord = await response.json();
                        showProblemDetails(updatedRecord);
                    } catch (error) {
                        console.error("Erro ao buscar o registro atualizado:", error);
                        alert("Erro ao atualizar os dados da ocorrência.");
                    }
                    }, 100);


                } else {
                    alert('Erro ao deletar o arquivo: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Erro:', error);
                alert('Erro ao deletar o arquivo.');
            });
        }
    }
    window.deleteFile = deleteFile;

    function downloadFile(url, filename) {
        try {
            // Se a URL já é uma URL completa de download, usa diretamente
            window.open(`/download_arquivo/${url}`, '_blank');
                if (url) {
                    null
                } else {
                    // Cria um elemento 'a' temporário para forçar o download
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename || 'arquivo';
                    link.target = '_blank';
                    
                    // Adiciona o link ao DOM temporariamente
                    document.body.appendChild(link);
                    
                    // Simula o clique no link
                    link.click();
                    
                    // Remove o link do DOM
                    document.body.removeChild(link);
                }
                
                // Feedback visual opcional
                //console.log(`Download iniciado: ${filename}`);
            } catch (error) {
                console.error('Erro ao fazer download:', error);
                alert('Erro ao fazer download do arquivo. Tente novamente.');
            }
        }
    function capitalizeFirstLetter(str) {
        str = str.toLowerCase()
        if (typeof str !== 'string' || str.length === 0) {
            return str; // Return as-is if not a string or empty
        }
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    const responsaveisPorPais = {{ responsaveis_por_pais|safe }};
    const todosResponsaveis = {{ todos_responsaveis|safe }};
    const paisesPorResponsavel = {};
    Object.keys(responsaveisPorPais).forEach(paisId => {
        responsaveisPorPais[paisId].forEach(responsavel => {
        if (!paisesPorResponsavel[responsavel.name]) {
            paisesPorResponsavel[responsavel.name] = [];
        }
        paisesPorResponsavel[responsavel.name].push(parseInt(paisId));
        });
    });
    document.addEventListener("DOMContentLoaded", function ( ) {
        "use strict";

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }
        // Montar lista de arquivos em HTML
        
        // Função para mostrar pop-up com detalhes do problema
        // Função para mostrar pop-up com detalhes do problema
        function showProblemDetails(record) {
            const arquivosListHTML = (record.arquivos && record.arquivos.length > 0)
            ? `<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                ${record.arquivos.map(arq => `
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; padding: 8px; background: white; border-radius: 6px; border: 1px solid #dee2e6;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">📎</span>
                            <span style="font-weight: 500; color: #495057;">${arq.nome_original || 'Arquivo'}</span>
                        </div>
                        <button onclick="deleteFile('${arq.id}', '${arq.nome_original}', ${JSON.stringify(record).replace(/"/g, '&quot;')})"
                                style="background: #dc3545; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; transition: background-color 0.2s;">
                            🗑 Deletar
                        </button>
                        <button onclick="downloadFile('${arq.id}', '${arq.nome_original || 'arquivo'}')" 
                                style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600; transition: background-color 0.2s;">
                            ⬇ Download
                        </button>
                    </div>
                `).join('')}
                </div>`
            : '<p style="color: #6c757d; font-style: italic;">Nenhum arquivo anexado.</p>';
            // Assegura que os valores sejam strings vazias se forem null/undefined
            const problemDetectedValue = record.problem_detected || '';
            const feedbackTechnicalValue = record.feedback_technical || '';
            const feedbackManagerValue = record.feedback_manager || '';

            // Gera um ID único para cada textarea para evitar conflitos
            const problemDetectedId = `problem_detected_${record.id}`;
            const feedbackTechnicalId = `feedback_technical_${record.id}`;
            const feedbackManagerId = `feedback_manager_${record.id}`;
            
            // Cria o conteúdo HTML do pop-up com informações detalhadas e textareas editáveis
            const popupContent = `
                <div style="text-align: left;">
                    <h3 style="color: var(--primary); margin-bottom: 20px;">Detalhes da Ocorrência</h3>
                    
                    <div style="background: var(--gray); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4 style="margin-top: 0; color: var(--text);">Problema Detectado:</h4>
                        <textarea id="${problemDetectedId}" 
                                  data-record-id="${record.id}" 
                                  data-field-name="problem_detected" 
                                  data-initial-value="${problemDetectedValue}"
                                  style="width: 100%; min-height: 100px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; font-family: inherit;">${problemDetectedValue}</textarea>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <strong>ID:</strong><br>
                            <span style="color: var(--text-light);">${record.id || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Técnico:</strong><br>
                            <span style="color: var(--text-light);">${record.technical || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>País:</strong><br>
                            <span style="color: var(--text-light);">${record.country || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Dispositivo:</strong><br>
                            <span style="color: var(--text-light);">${record.device || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Área:</strong><br>
                            <span style="color: var(--text-light);">${record.area || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Serial:</strong><br>
                            <span style="color: var(--text-light);">${record.serial || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Marca:</strong><br>
                            <span style="color: var(--text-light);">${record.brand || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Modelo:</strong><br>
                            <span style="color: var(--text-light);">${record.model || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Ano:</strong><br>
                            <span style="color: var(--text-light);">${record.year || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Versão:</strong><br>
                            <span style="color: var(--text-light);">${record.version || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Status:</strong><br>
                            <span style="color: var(--text-light);">${record.status || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Responsável:</strong><br>
                            <span style="color: var(--text-light);">${record.responsible || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Data:</strong><br>
                            <span style="color: var(--text-light);">${record.data ? formatDateToDisplay(record.data) : 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Prazo:</strong><br>
                            <span style="color: var(--text-light);">${record.deadline ? formatDateToDisplay(record.deadline) : 'Não definido'}</span>
                        </div>
                        <div>
                            <strong>Finalizado:</strong><br>
                            <span style="color: var(--text-light);">${record.finished ? formatDateToDisplay(record.finished) : 'Não finalizado'}</span>
                        </div>
                    </div>
                    
                    <div style="background: var(--gray); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h4 style="margin-top: 0; color: var(--primary);">Feedback Técnico:</h4>
                        <textarea id="${feedbackTechnicalId}" 
                                  data-record-id="${record.id}" 
                                  data-field-name="feedback_technical" 
                                  data-initial-value="${feedbackTechnicalValue}"
                                  style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; font-family: inherit;">${feedbackTechnicalValue}</textarea>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <h4>Arquivos anexados:</h4>
                        ${arquivosListHTML}
                        <h5 style="margin-top: 20px; margin-bottom: 10px; color: var(--secondary);">Adicionar novo arquivo:</h5>
                        
                        <div id="file-upload-wrapper-${record.id}" class="file-upload-wrapper full-width">
                            <div id="file-preview-container" class="file-preview-container"></div>

                            

                            <form method="POST" enctype="multipart/form-data" id="form-ocorrencia" class="file-upload">

                                {% csrf_token %}
                                
                                <input type="hidden" name="record" value="${record.id}"/>
                                <input type="hidden" name="page_num" value="${page_num}"/>
                                
                                <span class="container_buttons_popup">
                                    <label for="arquivo" class="custom-file-button">Selecionar Arquivos</label>
                                    <input type="file" id="arquivo" name="arquivo" multiple />
                                    <input type="submit" value="Cadastrar" required />
                                    <button type="button" id="clear-all-files-btn" class="clear-all-files-btn" style="display: none;">
                                        Limpar Tudo
                                    </button>
                                </span>
                            </form>
                        </div>
                    </div>
                    <div style="background: var(--gray); padding: 15px; border-radius: 8px;">
                        <h4 style="margin-top: 0; color: var(--warning);">Feedback do Gerente:</h4>
                        <textarea id="${feedbackManagerId}" 
                                  data-record-id="${record.id}" 
                                  data-field-name="feedback_manager" 
                                  data-initial-value="${feedbackManagerValue}"
                                  style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; font-family: inherit;">${feedbackManagerValue}</textarea>
                    </div>
                    
                </div>
            `;
            let id = record.id
            Swal.fire({
                title: 'Informações Detalhadas',
                html: popupContent,
                width: '80%',
                maxWidth: '800px',
                showCloseButton: true,
                showConfirmButton: true,
                confirmButtonText: 'Fechar',
                confirmButtonColor: '#0056b3',
                customClass: {
                    popup: 'problem-details-popup',
                    content: 'problem-details-content'
                },
                didOpen: () => {
                    // Adiciona event listeners para os textareas após o SweetAlert ser aberto
                    const problemDetectedTextarea = document.getElementById(problemDetectedId);
                    const feedbackTechnicalTextarea = document.getElementById(feedbackTechnicalId);
                    const feedbackManagerTextarea = document.getElementById(feedbackManagerId);
                    console.log(document.getElementById('form-ocorrencia'))
                    document.getElementById('form-ocorrencia').addEventListener('submit', async (e) => {
                        e.preventDefault();
                        const form = e.target;
                        const data = new FormData(form);
                        try {
                            const response = await fetch('{% url "update_ocorrencia/" %}', {
                                method: "POST",
                                headers: {
                                    'X-CSRFToken': data.get('csrfmiddlewaretoken')
                                },
                                body: data
                            });

                            if (!response.ok) {
                                throw new Error('Erro de rede ou do servidor');
                            }

                            const result = await response.json();

                            if (result.status === "success") {
                                await applyFiltersAndSort(); // Garante que os dados da tabela e arquivos sejam atualizados
                                Swal.close(); // Fecha o popup
                                setTimeout(async () => {
                                try {
                                    const response = await fetch(`/ocorrencia/get_record/${id}`);
                                    const updatedRecord = await response.json();
                                    showProblemDetails(updatedRecord);
                                } catch (error) {
                                    console.error("Erro ao buscar o registro atualizado:", error);
                                    alert("Erro ao atualizar os dados da ocorrência.");
                                }
                                }, 100);


                                
                            } else {
                                alert("Erro: " + result.message);
                            }
                        } catch (error) {
                            alert("Erro inesperado: " + error.message);
                        }
                    })
                    if (problemDetectedTextarea) {
                        problemDetectedTextarea.addEventListener('input', (e) => {
                            atualizarDadosPopup(e.target);
                        });
                    }
                    if (feedbackTechnicalTextarea) {
                        feedbackTechnicalTextarea.addEventListener('input', (e) => {
                            atualizarDadosPopup(e.target);
                        });
                    }
                    if (feedbackManagerTextarea) {
                        feedbackManagerTextarea.addEventListener('input', (e) => {
                            atualizarDadosPopup(e.target);
                        });
                    }
                    // --- INÍCIO DA LÓGICA DE UPLOAD COM PRÉ-VISUALIZAÇÃO ---

                    const uploadWrapper = document.getElementById(`file-upload-wrapper-${record.id}`);
                    const fileInput = document.getElementById('arquivo');
                    const previewContainer = document.getElementById('file-preview-container');
                    const clearAllBtn = document.getElementById('clear-all-files-btn'); // 1. SELECIONE O BOTÃO

                    let fileStore = new DataTransfer();

                    // Função para renderizar os cards de pré-visualização
                    const renderPreviews = () => {
                        previewContainer.innerHTML = ''; 
                        
                        Array.from(fileStore.files).forEach((file, index) => {
                            // ... (código de criação do card - sem alterações)
                            const card = document.createElement('div');
                            card.className = 'file-preview-card';
                            card.innerHTML = `
                                <span class="file-name" title="${file.name}">${file.name}</span>
                                <button type="button" class="remove-file-btn" data-index="${index}">&times;</button>
                            `;
                            previewContainer.appendChild(card);
                        });

                        // 2. MOSTRA/ESCONDE O BOTÃO "LIMPAR TUDO"
                        if (fileStore.files.length > 0) {
                            clearAllBtn.style.display = 'block';
                        } else {
                            clearAllBtn.style.display = 'none';
                        }

                        fileInput.files = fileStore.files;
                    };

                    // ... (função handleFiles - sem alterações) ...
                    const handleFiles = (files) => {
                        for (const file of files) {
                            fileStore.items.add(file);
                        }
                        renderPreviews();
                    };

                    // ... (event listener do previewContainer - sem alterações) ...
                    previewContainer.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-file-btn')) {
                            const indexToRemove = parseInt(e.target.dataset.index, 10);
                            const newFiles = new DataTransfer();
                            Array.from(fileStore.files).forEach((file, index) => {
                                if (index !== indexToRemove) {
                                    newFiles.items.add(file);
                                }
                            });
                            fileStore = newFiles;
                            renderPreviews();
                        }
                    });

                    // 3. ADICIONE O EVENT LISTENER PARA O BOTÃO "LIMPAR TUDO"
                    clearAllBtn.addEventListener('click', () => {
                        fileStore = new DataTransfer(); // Esvazia nossa lista de arquivos
                        renderPreviews(); // Renderiza novamente a UI (que ficará vazia)
                    });

                    // ... (Lógica de Drag and Drop e clique no input - sem alterações) ...
                    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                        uploadWrapper.addEventListener(eventName, (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                        }, false);
                    });
                    ['dragenter', 'dragover'].forEach(eventName => {
                        uploadWrapper.addEventListener(eventName, () => uploadWrapper.classList.add('drag-over'), false);
                    });
                    ['dragleave', 'drop'].forEach(eventName => {
                        uploadWrapper.addEventListener(eventName, () => uploadWrapper.classList.remove('drag-over'), false);
                    });
                    uploadWrapper.addEventListener('drop', (e) => {
                        handleFiles(e.dataTransfer.files);
                    }, false);
                    fileInput.addEventListener('change', () => {
                        handleFiles(fileInput.files);
                    });

                    // --- FIM DA LÓGICA DE UPLOAD ---
                }
            });
        }
        window.showProblemDetails = showProblemDetails;
    
        function generateFeedback(record){
            const feedbackTechnicalValue = record.feedback_technical || '';

            // Gera um ID único para cada textarea para evitar conflitos
            const feedbackTechnicalId = `feedback_technical_${record.id}`;
            
            // Cria o conteúdo HTML do pop-up com informações detalhadas e textareas editáveis
            const popupContent = `
                <div style="text-align: left;">
                    
                    
                    <div style="background: var(--gray); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <textarea id="${feedbackTechnicalId}" 
                                  data-record-id="${record.id}" 
                                  data-field-name="feedback_technical" 
                                  data-initial-value="${feedbackTechnicalValue}"
                                  style="width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; resize: vertical; font-family: inherit;">${feedbackTechnicalValue}</textarea>
                    </div>
                    
                </div>
            `;
            Swal.fire({
                title: 'Escreva seu feedback técnico',
                html: popupContent,
                width: '80%',
                maxWidth: '800px',
                showCloseButton: true,
                showConfirmButton: true,
                confirmButtonText: 'Fechar',
                confirmButtonColor: '#0056b3',
                customClass: {
                    popup: 'feedback-technical-popup',
                    content: 'feedback-technical-content'
                },
                didOpen: () => {
                    // Adiciona event listeners para os textareas após o SweetAlert ser aberto
                    const feedbackTechnicalTextarea = document.getElementById(feedbackTechnicalId);

                    if (feedbackTechnicalTextarea) {
                        feedbackTechnicalTextarea.addEventListener('input', (e) => {
                            atualizarDadosPopup(e.target);
                        });
                    }
                    
                }
            });
        }

        // Nova função para lidar com a atualização de dados no pop-up
        let typingTimerPopup;
        const doneTypingIntervalPopup = 100; // Tempo menor para salvar no pop-up, se desejar

        function atualizarDadosPopup(inputElement) {
            clearTimeout(typingTimerPopup);
            const initialValue = inputElement.getAttribute('data-initial-value');
            const currentValue = inputElement.value;

            if (currentValue !== initialValue) {
                inputElement.classList.add('pending-save');
                typingTimerPopup = setTimeout(() => saveFieldPopup(inputElement), doneTypingIntervalPopup);
            }
        }

        function saveFieldPopup(inputElement) {
            const recordID = inputElement.getAttribute('data-record-id');
            const fieldName = inputElement.getAttribute('data-field-name');
            const newValue = inputElement.value;

            inputElement.classList.remove('pending-save');
            inputElement.classList.add('saving'); // Opcional: Adicionar uma classe para indicar salvamento

            fetch('{% url "update_ocorrencia/" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': CSRF_TOKEN // Use o CSRF_TOKEN já definido
                },
                body: JSON.stringify({
                    id: recordID,
                    field: fieldName,
                    value: newValue,
                    // Não precisa de page_num aqui, a menos que a atualização afete a paginação
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Erro na requisição');
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    inputElement.classList.remove('saving');
                    inputElement.classList.add('success');
                    inputElement.setAttribute('data-initial-value', newValue); // Atualiza o valor inicial
                    
                    // Opcional: Atualizar a tabela principal para refletir a mudança imediatamente
                    // Isso pode ser feito chamando applyFiltersAndSort() ou atualizando a célula específica
                    // Se você quiser que a tabela principal reflita a mudança, chame applyFiltersAndSort()
                    applyFiltersAndSort(); 
                } else {
                    throw new Error(data.message || 'Erro desconhecido');
                }
                setTimeout(() => inputElement.classList.remove('success'), 2000); // Remove a classe 'success' após 2s
            })
            .catch(error => {
                console.error('Erro ao salvar no pop-up:', error.message);
                inputElement.classList.remove('saving');
                inputElement.classList.add('error');
                setTimeout(() => inputElement.classList.remove('error'), 5000);
            });
        }


        var page_num = 1
        let buttons_paginator = document.querySelectorAll('.button-paginator')
        var total_pages
        

        buttons_paginator.forEach(button=>{
            button.addEventListener('click', (e)=>{
                if(e.target.id == "next" && page_num <= total_pages){
                    page_num += 1
                }
                else if(e.target.id == "last" && page_num > 1){
                    page_num -= 1
                }
                applyFiltersAndSort()
            })
            
        })

        const buttons={
                elements: document.querySelector("#paginate #num_pages"),
                
                create(number){
                    const button = document.createElement("div")
                    button.innerHTML = number
                    button.className='page-item'

                    if(page_num == number){
                        button.classList.add("active")
                    }

                    buttons.elements.appendChild(button)
                },
                update(){
                    buttons.elements.innerHTML = ''
                    const {maxLeft, maxRight} = buttons.calculateMaxVisible()
                    
                    for(let page = maxLeft; page <= maxRight; page++){
                        buttons.create(page)
                    }

                },
                calculateMaxVisible(){
                    const maxVisibleButtons = 3
                    let maxLeft = (page_num - Math.floor(maxVisibleButtons/2))
                    let maxRight = (page_num + Math.floor(maxVisibleButtons/2))
                    
                    if(maxLeft < 1){
                        maxLeft = 1
                        maxRight = maxVisibleButtons
                    }
                    if(maxRight > total_pages){
                        maxLeft = total_pages - (maxVisibleButtons - 1)
                        maxRight = total_pages
                        if(maxLeft < 1){
                            maxLeft = 1
                        }
                    }
                    return {maxLeft, maxRight}
                }
            }

        function paginate(hasPrev, hasNext){
            const buttonPrev = document.getElementById("last")
            const buttonNext = document.getElementById("next")
            if(!hasPrev && hasNext){   
                buttonPrev.style.visibility = 'hidden'
                buttonNext.style.visibility = 'visible'
            }
            else if(!hasNext && hasPrev){
                buttonPrev.style.visibility = 'visible'
                buttonNext.style.visibility = 'hidden'
            }
            else if(!hasNext && !hasPrev){
                buttonPrev.style.visibility = 'hidden'
                buttonNext.style.visibility = 'hidden'
            }
            else{
                buttonPrev.style.visibility = 'visible'
                buttonNext.style.visibility = 'visible'
            }
            buttons.update()
        }

        function isValidDate(input) {
            // Verifica o formato com regex: dd/mm/yyyy
            const regex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
            const match = input.match(regex);

            if (!match) return false;

            const day = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const year = parseInt(match[3], 10);

            // Valida mês de 1 a 12
            if (month < 1 || month > 12) return false;

            // Cria a data com JS (os meses são de 0 a 11)
            const date = new Date(year, month - 1, day);

            // Verifica se o dia, mês e ano conferem
            return (
                date.getFullYear() === year &&
                date.getMonth() === month - 1 &&
                date.getDate() === day
            );
        }

        const table = document.getElementById("data-table");
        if (!table) {
            console.error("Erro: Tabela com ID \"data-table\" não encontrada.");
            return;
        }
        const tableBody = document.getElementById("table-body");
        if (!tableBody) {
            console.error("Erro: Corpo da tabela com ID \"table-body\" não encontrado.");
            return;
        }
        
        const headers = Array.from(table.querySelectorAll("thead th[data-column]")); 
        //console.log("Cabeçalhos encontrados no DOM:", headers.map(h => h.getAttribute("data-column")));

        const headerData = headers
            .map((header) => ({
                element: header,
                columnName: header.getAttribute("data-column"),
                filterBox: header.querySelector(".filter-box"),
                isDateColumn: ["data", "deadline", "finished"].includes(
                    header.getAttribute("data-column")
                ),
                isTextAreaColumn: ["feedback_technical", "feedback_manager"].includes(
                    header.getAttribute("data-column")
                ),
            }))
            .filter((h) => h.columnName);

        // console.log("HeaderData processado:", headerData.map(h => ({ col: h.columnName, hasFilterBox: !!h.filterBox })));

        let openFilterBox = null;
        let currentFilters = {}; 
        let currentSort = { column: "data", direction: "desc" };
        let currentFilterOptions = {}; // Armazena as opções de filtro recebidas do backend
        const CSRF_TOKEN = getCookie("csrftoken");

        // --- Funções Auxiliares --- 
        

        function parseDateToISO(dateString) { 
            if (!dateString || typeof dateString !== "string") return dateString;
            const parts = dateString.trim().split("/");
            if (parts.length === 3) {
                const [day, month, year] = parts;
                if (
                    day.length === 2 &&
                    month.length === 2 &&
                    year.length === 4 &&
                    !isNaN(parseInt(day)) &&
                    !isNaN(parseInt(month)) &&
                    !isNaN(parseInt(year))
                ) {
                    return `${year}-${month}-${day}`;
                }
            }
            if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return dateString;
            }
            return dateString;
        }
        
        function formatDateToDisplay(isoDateString) { 
            if (!isoDateString || typeof isoDateString !== "string") return "";
            const parts = isoDateString.split("-");
            if (parts.length === 3) {
                const [year, month, day] = parts;
                if (
                    day.length === 2 &&
                    month.length === 2 &&
                    year.length === 4 &&
                    !isNaN(parseInt(day)) &&
                    !isNaN(parseInt(month)) &&
                    !isNaN(parseInt(year))
                ) {
                    return `${day}/${month}/${year}`;
                }
            }
            return isoDateString;
        }

        // --- NOVA FUNÇÃO: Gerar ID único e válido ---
        function generateUniqueId(prefix, value, index = '') {
            // Remove caracteres especiais e espaços, substitui por underscore
            const sanitizedValue = String(value || 'empty')
                .replace(/[^a-zA-Z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '');
            
            // Adiciona timestamp para garantir unicidade
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substr(2, 5);
            
            return `${prefix}_${sanitizedValue}_${index}_${timestamp}_${randomSuffix}`;
        }

        // --- Lógica de UI (Filter Box) --- 
        function positionFilterBox(headerElement, filterBoxElement) { 
            const headerRect = headerElement.getBoundingClientRect();
            const tableRect = table.getBoundingClientRect();
            filterBoxElement.style.top = `${headerRect.bottom - tableRect.top + window.scrollY + 2}px`;
            filterBoxElement.style.display = "block";
            const boxRect = filterBoxElement.getBoundingClientRect();
        }

        // *** FUNÇÃO CORRIGIDA E MELHORADA: Criar a árvore de datas hierárquica com toggles ***
        function createDateTreeHTML(columnName, dateTree, level = 0) {
            let html = '';
            const sortedYears = Object.keys(dateTree).sort((a, b) => parseInt(a) - parseInt(b)); // Ordena anos numericamente

            sortedYears.forEach((year) => {
                const yearId = generateUniqueId(`date_${columnName}_year`, year);
                const yearToggleId = `toggle_${yearId}`;
                const yearContentId = `content_${yearId}`;

                html += `
                <div class="filter-tree-node" data-level="year">
                    <div class="node-header">
                        <span class="toggle-icon" id="${yearToggleId}">▶</span>
                        <input type="checkbox" id="${yearId}" data-filter-option="${columnName}" data-tree-level="year" value="${year}">
                        <label for="${yearId}">${year}</label>
                    </div>
                    <div class="node-content" id="${yearContentId}" style="display: none;">`; // Escondido por padrão

                const sortedMonths = Object.keys(dateTree[year]).sort((a, b) => parseInt(a) - parseInt(b)); // Ordena meses numericamente
                sortedMonths.forEach((month) => {
                    const monthName = new Date(2000, parseInt(month) - 1, 1).toLocaleString('pt-BR', { month: 'long' });
                    const monthId = generateUniqueId(`date_${columnName}_month`, `${year}_${month}`);
                    const monthToggleId = `toggle_${monthId}`;
                    const monthContentId = `content_${monthId}`;

                    html += `
                        <div class="filter-tree-node" data-level="month">
                            <div class="node-header" style="margin-left: 20px;">
                                <span class="toggle-icon" id="${monthToggleId}">▶</span>
                                <input type="checkbox" id="${monthId}" data-filter-option="${columnName}" data-tree-level="month" value="${year}-${month}">
                                <label for="${monthId}">${capitalize(monthName)}</label>
                            </div>
                            <div class="node-content" id="${monthContentId}" style="display: none;">`; // Escondido por padrão

                    const sortedDays = dateTree[year][month].sort((a, b) => parseInt(a) - parseInt(b)); // Ordena dias numericamente
                    sortedDays.forEach((day) => {
                        const dayId = generateUniqueId(`date_${columnName}_day`, `${year}_${month}_${day}`);
                        const fullDateValue = `${year}-${month}-${day}`;
                        html += `
                            <div class="filter-tree-node" data-level="day" style="margin-left: 40px;">
                                <input type="checkbox" id="${dayId}" data-filter-option="${columnName}" data-tree-level="leaf" value="${fullDateValue}">
                                <label for="${dayId}">${day}</label>
                            </div>`;
                    });
                    html += `</div></div>`; // Fecha node-content e filter-tree-node (month)
                });
                html += `</div></div>`; // Fecha node-content e filter-tree-node (year)
            });
            return html;
        }

        // *** FUNÇÃO CORRIGIDA E MELHORADA: Popular a caixa de filtro com IDs únicos e lógica de toggle ***
        function populateFilterBox(filterBoxElement, headerInfo) {
            const columnName = headerInfo.columnName;
            let options = currentFilterOptions[columnName] || (headerInfo.isDateColumn ? {} : []);
            
            // Para filtros não-data, garante que as opções sejam um array e únicas
            if (!headerInfo.isDateColumn) {
                try {
                    // --- INÍCIO DA NOVA LÓGICA PARA PADRONIZAÇÃO E UNICIDADE CASE-INSENSITIVE ---
                    const processedOptions = new Set(); // Usamos um Set para garantir unicidade
                    const uniqueOptions = []; // Array para as opções finais, mantendo a ordem de inserção ou ordenando depois

                    options.forEach(option => {
                        if (typeof option === "string") {
                            const trimmedUpper = option.trim().toUpperCase(); // Padroniza para maiúsculas
                            if (!processedOptions.has(trimmedUpper)) {
                                processedOptions.add(trimmedUpper);
                                uniqueOptions.push(option.trim()); // Adiciona a versão original (trim) para exibição
                            }
                        } else {
                            // Se não for string, adiciona como está (ex: números, booleanos)
                            if (!processedOptions.has(option)) { // Verifica unicidade para não-strings também
                                processedOptions.add(option);
                                uniqueOptions.push(option);
                            }
                        }
                    });
                    options = uniqueOptions.sort((a, b) => {
                        // Ordena as opções, tratando strings de forma case-insensitive
                        if (typeof a === 'string' && typeof b === 'string') {
                            return a.localeCompare(b, undefined, { sensitivity: 'base' });
                        }
                        return String(a).localeCompare(String(b)); // Para outros tipos, converte para string e compara
                    });
                    // --- FIM DA NOVA LÓGICA ---

                } catch (e) {
                    console.error("Erro ao processar opções de filtro não-data:", e);
                    options = [];
                }
            }


            const isDate = headerInfo.isDateColumn;
            const savedFilter = currentFilters[columnName] || { values: [], isApplied: false };
            
            let optionsHTML = '';
            if (isDate) {
                if (Object.keys(options).length > 0) {
                    optionsHTML = createDateTreeHTML(columnName, options);
                } else {
                    optionsHTML = '<p style="padding: 5px; color: grey;">Nenhuma data disponível.</p>';
                }
            } else {
                if (options.length > 0) {
                    options.forEach((option, index) => {
                        const optionId = generateUniqueId(`filter_${columnName}`, option, index);
                        const isChecked = savedFilter.isApplied && savedFilter.values.includes(option);
                        optionsHTML += `<div class="filter-option">
                                        <input type="checkbox" id="${optionId}" data-filter-option="${columnName}" data-tree-level="leaf" value="${option}" ${isChecked ? 'checked' : ''}>
                                        <label for="${optionId}">${option || '(Vazio)'}</label>
                                      </div>`;
                    });
                } else {
                    optionsHTML = '<p style="padding: 5px; color: grey;">Nenhuma opção disponível.</p>';
                }
            }

            filterBoxElement.innerHTML = `
                <div class="filter-header">
                    <input type="checkbox" id="select-all-${columnName}">
                    <label for="select-all-${columnName}">Selecionar Todos</label>
                </div>
                ${!isDate ? `<input type="text" class="filter-search-input" placeholder="Buscar...">` : ''}
                <div class="filter-options">${optionsHTML}</div>
                <div class="filter-actions">
                    <button class="apply-filter-btn">Aplicar</button>
                    <button class="clear-filter-btn">Limpar</button>
                </div>
            `;

            const selectAllCheckbox = filterBoxElement.querySelector(`#select-all-${columnName}`);
            const searchInput = filterBoxElement.querySelector('.filter-search-input');
            const applyButton = filterBoxElement.querySelector('.apply-filter-btn');
            const clearButton = filterBoxElement.querySelector('.clear-filter-btn');
            const optionCheckboxes = filterBoxElement.querySelectorAll('input[type="checkbox"][data-filter-option]');

            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    const isChecked = this.checked;
                    optionCheckboxes.forEach(checkbox => {
                        checkbox.checked = isChecked;
                    });
                });
            }

            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase();
                    const filterOptions = filterBoxElement.querySelectorAll('.filter-option');
                    
                    filterOptions.forEach(option => {
                        const label = option.querySelector('label');
                        if (label) {
                            const text = label.textContent.toLowerCase();
                            option.style.display = text.includes(searchTerm) ? 'block' : 'none';
                        }
                    });
                });
            }

            if (applyButton) {
                applyButton.addEventListener('click', function() {
                    const selectedValues = [];
                    optionCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedValues.push(checkbox.value);
                        }
                    });

                    currentFilters[columnName] = {
                        values: selectedValues,
                        isApplied: selectedValues.length > 0
                    };

                    applyFiltersAndSort(true);
                });
            }

            if (clearButton) {
                clearButton.addEventListener('click', function() {
                    currentFilters[columnName] = { values: [], isApplied: false };
                    applyFiltersAndSort(true);
                });
            }

            if (isDate) {
                addDateHierarchyToggle(filterBoxElement, columnName);
            }
        }

        // *** NOVA FUNÇÃO: Adicionar funcionalidade de toggle hierárquico para datas e sincronização de checkboxes ***
        function addDateHierarchyToggle(filterBoxElement, columnName) {
            const toggleIcons = filterBoxElement.querySelectorAll('.toggle-icon');
            
            toggleIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    const contentId = `content_${this.id.replace('toggle_', '')}`;
                    const contentElement = filterBoxElement.querySelector(`#${contentId}`);
                    if (contentElement) {
                        if (contentElement.style.display === 'none') {
                            contentElement.style.display = 'block';
                            this.textContent = '▼'; // Seta para baixo
                        } else {
                            contentElement.style.display = 'none';
                            this.textContent = '▶'; // Seta para a direita
                        }
                    }
                });
            });

            // Sincronização de checkboxes
            filterBoxElement.addEventListener('change', function(event) {
                const target = event.target;
                if (target.type === 'checkbox' && target.dataset.filterOption === columnName) {
                    const level = target.dataset.treeLevel;
                    const value = target.value;
                    const isChecked = target.checked;

                    if (level === 'year') {
                        // Se um ano é marcado/desmarcado, afeta todos os meses e dias abaixo dele
                        filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${value}-"], input[data-tree-level="leaf"][value^="${value}-"]`).forEach(checkbox => {
                            checkbox.checked = isChecked;
                        });
                    } else if (level === 'month') {
                        // Se um mês é marcado/desmarcado, afeta todos os dias abaixo dele
                        filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${value}-"]`).forEach(checkbox => {
                            checkbox.checked = isChecked;
                        });

                        // Verifica o estado do ano pai
                        const year = value.split('-')[0];
                        const yearCheckbox = filterBoxElement.querySelector(`input[data-tree-level="year"][value="${year}"]`);
                        if (yearCheckbox) {
                            const allMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]`);
                            const checkedMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]:checked`);
                            yearCheckbox.checked = allMonthsOfYear.length === checkedMonthsOfYear.length;
                        }
                    } else if (level === 'leaf') {
                        // Se um dia é marcado/desmarcado, verifica o estado do mês pai
                        const yearMonth = value.substring(0, value.lastIndexOf('-')); // Ex: "2023-01"
                        const monthCheckbox = filterBoxElement.querySelector(`input[data-tree-level="month"][value="${yearMonth}"]`);
                        if (monthCheckbox) {
                            const allDaysOfMonth = filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${yearMonth}-"]`);
                            const checkedDaysOfMonth = filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${yearMonth}-"]:checked`);
                            monthCheckbox.checked = allDaysOfMonth.length === checkedDaysOfMonth.length;
                        }

                        // E também verifica o estado do ano pai
                        const year = value.split('-')[0];
                        const yearCheckbox = filterBoxElement.querySelector(`input[data-tree-level="year"][value="${year}"]`);
                        if (yearCheckbox) {
                            const allMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]`);
                            const checkedMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]:checked`);
                            yearCheckbox.checked = allMonthsOfYear.length === checkedMonthsOfYear.length;
                        }
                    }
                }
            });
        }

        // --- Lógica de Filtragem e Ordenação ---
        function applyFiltersAndSort(closeBox = false) {
            // 1. Preparar dados de filtro
            const filterData = {
                filters: {},
                sort: currentSort,
                page: page_num
            };
            if('{{has_full_permission}}' == 'False'){
                filterData.filters['responsible'] = []
                filterData.filters['responsible'].push('{{user}}'.toUpperCase())
            }

            // 2. Processar filtros ativos
            Object.keys(currentFilters).forEach(columnName => {
                const filter = currentFilters[columnName];
                if (filter.isApplied && filter.values.length > 0) {
                    const headerInfo = headerData.find(h => h.columnName === columnName);
                    
                    if (headerInfo?.isDateColumn) {
                        // Para datas, converter para ISO
                        filterData.filters[columnName] = filter.values.map(parseDateToISO);
                    } else {
                        filterData.filters[columnName] = filter.values;
                    }
                }
            });

            // 3. Enviar para o backend
            fetch("{% url 'filter_data' %}", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": CSRF_TOKEN,
                },
                body: JSON.stringify(filterData),
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) throw new Error(data.error);
                
                currentFilterOptions = data.filter_options || {};
                updateTable(data.records);
                total_pages = data.num_pages;
                paginate(data.has_previous, data.has_next);

                // --- INÍCIO DA NOVA LÓGICA PARA FEEDBACK VISUAL DE FILTRO ---
                // Remove a classe 'filtered' de todos os cabeçalhos primeiro
                headers.forEach(header => {
                    header.classList.remove('filtered');
                });

                // Adiciona a classe 'filtered' aos cabeçalhos com filtros ativos
                Object.keys(currentFilters).forEach(columnName => {
                    const filter = currentFilters[columnName];
                    if (filter.isApplied && filter.values.length > 0) {
                        const headerInfo = headerData.find(h => h.columnName === columnName);
                        if (headerInfo && headerInfo.element) {
                            headerInfo.element.classList.add('filtered');
                        }
                    }
                });
                // --- FIM DA NOVA LÓGICA PARA FEEDBACK VISUAL DE FILTRO ---

            })
            .catch(error => {
                console.error("Erro ao filtrar:", error);
                Swal.fire("Erro", "Ocorreu um erro ao aplicar os filtros.", "error");
            });

            // 4. Fechar a caixa de filtro se necessário
            if (closeBox && openFilterBox) {
                openFilterBox.style.display = "none";
                openFilterBox = null;
            }
        }
        window.applyFiltersAndSort = applyFiltersAndSort;
    

        /**
        * Atualiza o corpo da tabela.
        */
        // ===== SISTEMA DE ATUALIZAÇÃO DINÂMICA DE STATUS =====
        // Simula o comportamento de useEffect do React em JavaScript puro

        // Estado global para controlar atualizações
        let statusUpdateSystem = {
            records: [],
            isInitialized: false,
            observers: new Map(),
            debounceTimers: new Map()
        };

        // Função pura para calcular o status baseado nas datas
        function calculateStatus(record) {
            const deadlineStr = record.deadline; // Formato: DD/MM/YYYY
            const finishedStr = record.finished; // Formato: DD/MM/YYYY
            
            // Se tem data de finalização, sempre é "Concluído"
            if (finishedStr && finishedStr !== "Não finalizado") {
                return 'Concluído';
            }
            
            // Se não tem prazo definido, é "Requisitado"
            if (!deadlineStr || deadlineStr === "Não definido") {
                return 'Requisitado';
            }
            
            // Converte data do formato DD/MM/YYYY para Date
            const parseDate = (dateStr) => {
                if (!dateStr || dateStr === "Não definido" || dateStr === "Não finalizado") return null;
                const [day, month, year] = dateStr.split('/').map(Number);
                return new Date(year, month - 1, day); // month - 1 porque Date usa 0-11 para meses
            };
            
            const deadlineDate = parseDate(deadlineStr);
            if (!deadlineDate) return 'Requisitado';
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Zera as horas para comparar apenas a data
            
            const deadline = new Date(deadlineDate);
            deadline.setHours(0, 0, 0, 0);
            
            // Compara as datas
            if (today > deadline) {
                return 'Atrasado';
            } else {
                return 'Em progresso';
            }
        }

        // Função para atualizar o status de um registro específico
        function updateRecordStatus(recordId, newStatus) {
            const statusCell = document.querySelector(`[data-column="status"][data-id="${recordId}"]`);
            if (!statusCell) return;
            
            const currentStatus = statusCell.textContent.trim();
            
            // Só atualiza se o status mudou
            if (currentStatus !== newStatus) {
                statusCell.textContent = newStatus;
                
                // Cria um elemento mock para usar com a função saveField existente
                const mockElement = {
                    value: newStatus,
                    closest: () => statusCell,
                    classList: { add: () => {}, remove: () => {} },
                    setAttribute: () => {}
                };
                
                // Chama a função saveField para persistir no backend
                if (typeof saveField === 'function') {
                    saveField(mockElement);
                }
                statusCell.setAttribute('data-initial-value', newStatus)
                //console.log(`Status atualizado para registro ${recordId}: ${currentStatus} → ${newStatus}`);
            }
        }

        // Função para recalcular todos os status
        function recalculateAllStatus() {
            statusUpdateSystem.records.forEach(record => {
                const newStatus = calculateStatus(record);
                updateRecordStatus(record.id, newStatus);
            });
        }

        // Função para recalcular status de um registro específico
        function recalculateRecordStatus(recordId) {
            const record = statusUpdateSystem.records.find(r => r.id == recordId);
            if (!record) return;
            
            // Atualiza os dados do record com os valores atuais dos inputs
            const deadlineInput = document.querySelector(`[data-column="deadline"][data-id="${recordId}"] input`);
            const finishedInput = document.querySelector(`[data-column="finished"][data-id="${recordId}"] input`);
            
            if (deadlineInput) {
                record.deadline = deadlineInput.value || deadlineInput.placeholder;
            }
            if (finishedInput) {
                record.finished = finishedInput.value || finishedInput.placeholder;
            }
            
            const newStatus = calculateStatus(record);
            updateRecordStatus(recordId, newStatus);
        }

        // Função com debounce para evitar execuções excessivas
        function debounce(func, wait, key) {
            if (statusUpdateSystem.debounceTimers.has(key)) {
                clearTimeout(statusUpdateSystem.debounceTimers.get(key));
            }
            
            const timer = setTimeout(() => {
                func();
                statusUpdateSystem.debounceTimers.delete(key);
            }, wait);
            
            statusUpdateSystem.debounceTimers.set(key, timer);
        }

        // Função para configurar observadores nos inputs de data
        function setupDateInputObservers() {
            // Remove observadores existentes
            statusUpdateSystem.observers.forEach(observer => observer.disconnect());
            statusUpdateSystem.observers.clear();
            
            // Configura observadores para inputs de deadline e finished
            const dateInputs = document.querySelectorAll('[data-column="deadline"] input, [data-column="finished"] input');
            
            dateInputs.forEach(input => {
                const cell = input.closest('[data-id]');
                if (!cell) return;
                
                const recordId = cell.getAttribute('data-id');
                const columnName = cell.getAttribute('data-column');
                
                // Event listener para mudanças no input
                const handleInputChange = () => {
                    debounce(() => {
                        recalculateRecordStatus(recordId);
                    }, 300, `${recordId}-${columnName}`);
                };
                
                // Remove listeners existentes para evitar duplicação
                input.removeEventListener('input', handleInputChange);
                input.removeEventListener('change', handleInputChange);
                input.removeEventListener('blur', handleInputChange);
                
                // Adiciona os listeners
                input.addEventListener('input', handleInputChange);
                input.addEventListener('change', handleInputChange);
                input.addEventListener('blur', handleInputChange);
                
                //console.log(`Observer configurado para ${columnName} do registro ${recordId}`);
            });
            
            // MutationObserver para detectar mudanças no DOM (quando novos inputs são adicionados)
            const tableObserver = new MutationObserver((mutations) => {
                let shouldReconfigure = false;
                
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const hasDateInputs = node.querySelectorAll && 
                                node.querySelectorAll('[data-column="deadline"] input, [data-column="finished"] input').length > 0;
                            
                            if (hasDateInputs) {
                                shouldReconfigure = true;
                            }
                        }
                    });
                });
                
                if (shouldReconfigure) {
                    debounce(() => {
                        setupDateInputObservers();
                        recalculateAllStatus();
                    }, 100, 'dom-mutation');
                }
            });
            
            // Observa mudanças no tbody da tabela
            const tableBody = document.getElementById('table-body');
            if (tableBody) {
                tableObserver.observe(tableBody, {
                    childList: true,
                    subtree: true
                });
                statusUpdateSystem.observers.set('table-mutation', tableObserver);
            }
        }

        // Função melhorada updateTable com sistema de atualização dinâmica
        function updateTable(records) {
            // Armazena os records no sistema de status
            statusUpdateSystem.records = records || [];
            
            tableBody.innerHTML = "";
            if (!records || records.length === 0) {
                const colspan = table.querySelectorAll("thead th[data-column]").length;
                const noResultsRow = tableBody.insertRow();
                const cell = noResultsRow.insertCell();

                cell.colSpan = colspan > 0 ? colspan : 1;
                cell.textContent = "Nenhum registro encontrado.";
                cell.style.textAlign = "center";
                return;
            }
            
            const visibleColumns = Array.from(table.querySelectorAll("thead th[data-column]")).map(th => th.getAttribute('data-column'));
            let has_full_permission = '{{has_full_permission}}'

            records.forEach((record) => {
                const row = tableBody.insertRow();
                visibleColumns.forEach(columnName => {
                    const cell = row.insertCell();
                    cell.setAttribute("data-column", columnName);
                    cell.setAttribute("data-id", record.id)

                    let value = record[columnName];
                    const headerInfo = headerData.find(h => h.columnName === columnName);
                    
                    if (headerInfo?.isDateColumn) {
                        if (value) {
                            value = formatDateToDisplay(value);
                        } else {
                            if (columnName == 'finished') {
                                value = "Não finalizado"
                            } else {
                                value = 'Não definido'
                            }
                        }
                    }

                    if (columnName == 'problem_detected') {
                        cell.classList.add("no-cursor")
                        
                        const container = document.createElement('div');
                        container.style.display = 'flex';
                        container.style.alignItems = 'center';
                        container.style.justifyContent = 'center';
                        
                        const detailsButton = document.createElement('button');
                        detailsButton.innerHTML = 'Ver Detalhes';
                        detailsButton.style.cssText = `
                            background: linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8rem;
                            font-weight: 600
                        `;
                        
                        detailsButton.addEventListener('mouseenter', function() {
                            this.style.background = 'linear-gradient(135deg, #3a7bc8 0%, #0056b3 100%)';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 4px 12px rgba(0, 86, 179, 0.3)';
                        });
                        
                        detailsButton.addEventListener('mouseleave', function() {
                            this.style.background = 'linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%)';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        });
                        
                        detailsButton.addEventListener('click', function(e) {
                            e.stopPropagation();
                            showProblemDetails(record);
                        });
                        
                        container.appendChild(detailsButton);
                        cell.appendChild(container);

                    } else if (columnName == 'feedback_technical') {
                        cell.classList.add("no-cursor")
                        
                        const container = document.createElement('div');
                        container.style.display = 'flex';
                        container.style.alignItems = 'center';
                        container.style.justifyContent = 'center';
                        
                        const detailsButton = document.createElement('button');
                        detailsButton.innerHTML = 'Gerenciar feedback';
                        detailsButton.style.cssText = `
                            background: linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8rem;
                            font-weight: 600
                        `;
                        
                        detailsButton.addEventListener('mouseenter', function() {
                            this.style.background = 'linear-gradient(135deg, #3a7bc8 0%, #0056b3 100%)';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 4px 12px rgba(0, 86, 179, 0.3)';
                        });
                        
                        detailsButton.addEventListener('mouseleave', function() {
                            this.style.background = 'linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%)';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        });
                        
                        detailsButton.addEventListener('click', function(e) {
                            e.stopPropagation();
                            generateFeedback(record);
                        });
                        
                        container.appendChild(detailsButton);
                        cell.appendChild(container);

                    } else if (columnName == 'status') {
                        // === NOVA LÓGICA DE STATUS DINÂMICA ===
                        cell.id = `${columnName}${record.id}`;
                        cell.classList.add('field-container');
                        
                        // Calcula o status correto baseado nas datas
                        const calculatedStatus = calculateStatus(record);
                        cell.textContent = calculatedStatus;
                        cell.setAttribute('data-initial-value', calculatedStatus);
                        // Se o status calculado for diferente do que veio do backend, atualiza
                        if (calculatedStatus !== record[columnName]) {
                            const mockElement = {
                                value: calculatedStatus,
                                closest: () => cell,
                                classList: { add: () => {}, remove: () => {} },
                                setAttribute: () => {}
                            };
                            
                            if (typeof saveField === 'function') {
                                saveField(mockElement);
                            }
                        }

                    } else if ((columnName == 'deadline' && '{{has_full_permission}}' === 'True') || columnName == 'finished') {
                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('editable-field-container')
                        cell.classList.add('date-input-container')

                        const textInput = document.createElement('input');
                        textInput.type = 'text';
                        textInput.placeholder = 'DD/MM/AAAA';
                        textInput.classList.add('date-text-input')
                        
                        cell.addEventListener('dblclick', (e) => {
                            navigator.clipboard.writeText(e.target.getAttribute('data-initial-value'))
                            textInput.blur()
                            Swal.fire({
                                title: "Texto copiado",
                                text: 'Data copiada para área de transferência',
                                showCloseButton: true,
                                icon: 'success'
                            })
                        })

                        textInput.placeholder = value;
                        textInput.setAttribute('data-initial-value', value)

                        cell.appendChild(textInput);

                        textInput.addEventListener('blur', function(e) {
                            e.target.classList.remove("erro")
                            e.target.classList.remove("success")
                        })

                        textInput.addEventListener('input', function(e) {
                            let value = e.target.value.replace(/\D/g, '');

                            if (value.length > 2) value = value.substring(0, 2) + '/' + value.substring(2);
                            if (value.length > 5) value = value.substring(0, 5) + '/' + value.substring(5, 9);

                            e.target.value = value;
                            
                            if (columnName == 'finished') {
                                if (value.split('/').length != 3) {
                                    e.target.classList.add("erro")
                                    e.target.classList.remove("success")
                                } else {
                                    var deadline_data = new Date(`${record['deadline'].split('/')[2]}-${record['deadline'].split('/')[1]}-${record['deadline'].split('/')[0]}`)
                                    var input_data = new Date(`${value.split('/')[2]}-${value.split('/')[1]}-${value.split('/')[0]}`)

                                    if (value.split('/')[2].length == 4 && isValidDate(value)) {
                                        e.target.classList.remove("erro")
                                        e.target.classList.add("success")
                                        atualizarDados(e)
                                    } else {
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    }
                                }
                            } else if (columnName == 'deadline') {
                                if (value.split('/').length != 3) {
                                    e.target.classList.add("erro")
                                    e.target.classList.remove("success")
                                } else {
                                    var finished = record['finished'] ? new Date(`${record['finished'].split('/')[2]}-${record['finished'].split('/')[1]}-${record['finished'].split('/')[0]}`) : null;
                                    var data = new Date(record['data'])
                                    var input_data = new Date(`${value.split('/')[2]}-${value.split('/')[1]}-${value.split('/')[0]}`)
                                    
                                    if (input_data < data) {
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    } else if (finished && input_data > finished) {
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    } else if (value.split('/')[2].length == 4 && isValidDate(value)) {
                                        e.target.classList.remove("erro")
                                        e.target.classList.add("success")
                                        atualizarDados(e)
                                    } else {
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    }
                                }
                            }
                        })
                        
                        if (textInput.classList[0] == 'date-text-input') {
                            flatpickr('.date-text-input', { 'allowInput': true, 'dateFormat': 'd/m/Y', 'minDate': 'today' })
                        }

                    } else if ((columnName == 'responsible' && '{{has_full_permission}}' === 'True')) {
                        cell.id = `${columnName}${record.id}`;
                        cell.classList.add('editable-field-container');
                        cell.classList.add('date-input-container');

                        const select = document.createElement('select');
                        select.setAttribute('data-initial-value', value);
                        select.placeholder = value;
                        select.id = `${columnName}${record.id}`;

                        select.addEventListener('change', (e) => atualizarDados(e));

                        const optionPlaceholder = document.createElement('option');
                        optionPlaceholder.textContent = '-- Selecione o responsável --';
                        optionPlaceholder.disabled = true;
                        optionPlaceholder.selected = !value;
                        select.appendChild(optionPlaceholder);

                        cell.appendChild(select);

                        const responsaveis = responsaveisPorPais[record.country]

                        if (responsaveis) {
                            responsaveis.forEach(responsavel => {
                                const opt = document.createElement('option');
                                opt.textContent = capitalizeFirstLetter(responsavel.name)
                                opt.value = responsavel.name
                                if (value && responsavel.name.toUpperCase() === value.toUpperCase()) {
                                    opt.selected = true;
                                }
                                select.appendChild(opt);
                            });
                        }

                    } else if (headerInfo.isTextAreaColumn) {
                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('editable-field-container')
                        cell.classList.add('date-input-container')

                        let textArea = document.createElement('textarea')
                        textArea.setAttribute('data-initial-value', value)
                        textArea.rows = 5
                        textArea.cols = 20
                        textArea.placeholder = value
                        textArea.id = `${columnName}${record.id}`
                        textArea.addEventListener('input', (e) => atualizarDados(e))
                        textArea.addEventListener('dblclick', (e) => {
                            navigator.clipboard.writeText(e.target.getAttribute('data-initial-value'))
                            Swal.fire({
                                title: "Texto copiado",
                                text: 'Feedback copiado para área de transferência',
                                showCloseButton: true,
                                icon: 'success'
                            })
                        })
                        cell.appendChild(textArea)

                    } else {
                        cell.textContent = (value !== null && value !== undefined) ? value : "";
                    }
                });
            });
            
            // Configura os observadores após renderizar a tabela
            setTimeout(() => {
                setupDateInputObservers();
                if (!statusUpdateSystem.isInitialized) {
                    recalculateAllStatus();
                    statusUpdateSystem.isInitialized = true;
                }
            }, 100);
        }

        // Função para inicializar o sistema de atualização dinâmica
        function initializeStatusUpdateSystem() {
            //console.log('Sistema de atualização dinâmica de status inicializado');
            
            // Configura um observer global para detectar mudanças na página
            const globalObserver = new MutationObserver((mutations) => {
                let hasTableChanges = false;
                
                mutations.forEach((mutation) => {
                    if (mutation.target.id === 'table-body' || 
                        mutation.target.closest('#table-body')) {
                        hasTableChanges = true;
                    }
                });
                
                if (hasTableChanges) {
                    debounce(() => {
                        setupDateInputObservers();
                    }, 200, 'global-table-change');
                }
            });
            
            // Observa mudanças em toda a página
            globalObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            statusUpdateSystem.observers.set('global', globalObserver);
        }

        // Inicializa o sistema quando o DOM estiver pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeStatusUpdateSystem);
        } else {
            initializeStatusUpdateSystem();
        }



        // --- Inicialização ---
        //console.log("Inicializando event listeners para cabeçalhos...");
        headerData.forEach((headerInfo) => {
            const { element: headerElement, filterBox: filterBoxElement, columnName } = headerInfo;
            if (filterBoxElement) { 
                //console.log(`Adicionando listener de clique para ${columnName}`);
                filterBoxElement.id = `filter-box-${columnName}`;
                headerElement.addEventListener("click", (event) => {
                    //console.log(`Clique detectado no cabeçalho ${columnName}`);
                    if (event.target.closest(".filter-box")) {
                        //console.log("Clique dentro da filter-box, ignorando.");
                        return; 
                    }
                    if (openFilterBox && openFilterBox !== filterBoxElement) {
                        //console.log("Fechando outra filter-box aberta.");
                        openFilterBox.style.display = "none";
                    }
                    const isCurrentlyOpen = filterBoxElement.style.display === "block";
                    if (isCurrentlyOpen) {
                        //console.log(`Fechando filter-box para ${columnName}`);
                        filterBoxElement.style.display = "none";
                        openFilterBox = null;
                    } else {
                        //console.log(`Abrindo filter-box para ${columnName}`);
                        // *** AGORA POPULA COM OPÇÕES DINÂMICAS ***
                        populateFilterBox(filterBoxElement, headerInfo); 
                        
                        filterBoxElement.style.display = "block";
                        positionFilterBox(headerElement, filterBoxElement);
                        openFilterBox = filterBoxElement;
                        const searchInput = filterBoxElement.querySelector(".filter-search-input");
                        if (searchInput) searchInput.focus();
                    }
                    event.stopPropagation(); 
                });
            } else {
                 //console.log(`Sem filter-box para ${columnName}, listener não adicionado.`);
            }
        });

        // Listener para fechar a caixa ao clicar fora
        document.addEventListener("click", (event) => {
            if (
                openFilterBox &&
                !event.target.closest("th") && 
                !openFilterBox.contains(event.target) 
            ) {
                //console.log("Clique fora, fechando filter-box.");
                openFilterBox.style.display = "none";
                openFilterBox = null;
            }
        });
        
        // Chama para carregar dados iniciais via AJAX
        //console.log("Chamando applyFiltersAndSort para carregamento inicial...");
        applyFiltersAndSort(false); 

        let typingTimer;
        const doneTypingInterval = 100;

        function atualizarDados(e){   
            clearTimeout(typingTimer);   
            let dado = e.target ? e.target : e
                
            let valor_inicial = dado.getAttribute('data-initial-value')
            let valor_input = dado.value
            if(valor_input !== valor_inicial) {
                dado.classList.add('pending-save')
                typingTimer = setTimeout(() => saveField(dado), doneTypingInterval);
            }
            
        }
        function saveField(inputElement) {
            const container = inputElement.closest('.editable-field-container') ? inputElement.closest('.editable-field-container') : inputElement.closest('.field-container');
            const reportID = container.getAttribute('data-id');
            const fieldName = container.getAttribute('data-column');
            const newValue = inputElement.value
            
            
            fetch('{% url "update_ocorrencia/" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'  // Envia o CSRF token no cabeçalho
                },
                body: JSON.stringify({
                    id: reportID,
                    field: fieldName,
                    value: newValue,
                    page_num: page_num
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Erro na requisição');
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    inputElement.classList.remove('pending-save', 'saving');
                    inputElement.setAttribute('data-initial-value', newValue);
                    
                    // Atualiza o display se necessário
                    if (data.display_value) {
                        inputElement.value = data.display_value;
                        inputElement.setAttribute('placeholder', data.display_value);
                        inputElement.dataset.initialValue = data.display_value;
                    }
                }
                // location.reload();
                page_num = data.page_num
                setTimeout(() => inputElement.classList.remove('success'), 5000);
            })
            .catch(error => {
                console.error('Erro:', error.message);
                inputElement.classList.remove('saving');
                inputElement.classList.add('error');
                setTimeout(() => inputElement.classList.remove('error'), 5000);
            });
    

        }
        
    

    });
    
    // Após definição de todas as funções:
    

</script>

</body>
</html>
