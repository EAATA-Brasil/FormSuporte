{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="{% static 'ocorrencia/css/styles.css' %}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>
<body>

    <table id="data-table" class="table">
        <thead>
            <tr>
                {% include 'ocorrencia/components/lineHead.html' with name='data' ID="data"%}
                {% include 'ocorrencia/components/lineHead.html' with name='technical' ID="technical"%}
                {% include 'ocorrencia/components/lineHead.html' with name='país' ID="country"%}
                {% include 'ocorrencia/components/lineHead.html' with name='device' ID="device"%}
                {% include 'ocorrencia/components/lineHead.html' with name='area' ID="area"%}
                {% include 'ocorrencia/components/lineHead.html' with name='brand' ID="brand"%}
                {% include 'ocorrencia/components/lineHead.html' with name='model' ID="model"%}
                {% include 'ocorrencia/components/lineHead.html' with name='Problem Detected' ID="problem_detected" checbox='false'%}
                {% include 'ocorrencia/components/lineHead.html' with name='status' ID="status"%}
                {% include 'ocorrencia/components/lineHead.html' with name='deadline' ID="deadline"%}
                {% include 'ocorrencia/components/lineHead.html' with name='responsible' ID="responsible"%}
                {% include 'ocorrencia/components/lineHead.html' with name='finished' ID="finished"%}
                {% include 'ocorrencia/components/lineHead.html' with name='Feedback Technical' ID="feedback_technical" checbox='false'%}
                {% include 'ocorrencia/components/lineHead.html' with name='Feedback Manager' ID="feedback_manager" checbox='false'%}
            </tr>
            
        </thead>
        <tbody id="table-body">
        {# O corpo da tabela será preenchido via AJAX #}
        </tbody>
    </table>
    
    <div id="paginate">
        <span class="button-paginator" id="last">Voltar</span>
        <span id="num_pages">
            
        </span>
        <span class="button-paginator" id="next">Avançar</span>
    </div>
    <a href="{% url 'subir_ocorrencia' %}" style="padding: 0.6rem 1.2rem;
    font-size: 1rem;
    border: none;
    border-radius: 0.3rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
    text-decoration: none;
    display: inline-block;
    background-color: #157347;
    color: var(--light);">
        <i class="fas fa-plus"></i> Novo Ocorrência
    </a>

<script>
    document.addEventListener("DOMContentLoaded", function ( ) {
        "use strict";

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
        }

        // Função para mostrar pop-up com detalhes do problema
        function showProblemDetails(record) {
            const problemText = record.problem_detected || 'Nenhum problema detectado';
            
            // Cria o conteúdo HTML do pop-up com informações detalhadas
            const popupContent = `
                <div style="text-align: left;">
                    <h3 style="color: #0056b3; margin-bottom: 20px;">Detalhes do Problema</h3>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h4 style="margin-top: 0; color: #333;">Problema Detectado:</h4>
                        <p style="margin: 0; line-height: 1.6; word-wrap: break-word;">${problemText}</p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <strong>Técnico:</strong><br>
                            <span style="color: #666;">${record.technical || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>País:</strong><br>
                            <span style="color: #666;">${record.country || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Dispositivo:</strong><br>
                            <span style="color: #666;">${record.device || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Área:</strong><br>
                            <span style="color: #666;">${record.area || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Serial:</strong><br>
                            <span style="color: #666;">${record.serial || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Marca:</strong><br>
                            <span style="color: #666;">${record.brand || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Modelo:</strong><br>
                            <span style="color: #666;">${record.model || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Ano:</strong><br>
                            <span style="color: #666;">${record.year || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Versão:</strong><br>
                            <span style="color: #666;">${record.version || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Status:</strong><br>
                            <span style="color: #666;">${record.status || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Responsável:</strong><br>
                            <span style="color: #666;">${record.responsible || 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Data:</strong><br>
                            <span style="color: #666;">${record.data ? formatDateToDisplay(record.data) : 'Não informado'}</span>
                        </div>
                        <div>
                            <strong>Prazo:</strong><br>
                            <span style="color: #666;">${record.deadline ? formatDateToDisplay(record.deadline) : 'Não definido'}</span>
                        </div>
                        <div>
                            <strong>Finalizado:</strong><br>
                            <span style="color: #666;">${record.finished ? formatDateToDisplay(record.finished) : 'Não finalizado'}</span>
                        </div>
                    </div>
                    
                    ${record.feedback_technical ? `
                        <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <h4 style="margin-top: 0; color: #0056b3;">Feedback Técnico:</h4>
                            <p style="margin: 0; line-height: 1.6; word-wrap: break-word;">${record.feedback_technical}</p>
                        </div>
                    ` : ''}
                    
                    ${record.feedback_manager ? `
                        <div style="background: #fff3cd; padding: 15px; border-radius: 8px;">
                            <h4 style="margin-top: 0; color: #856404;">Feedback do Gerente:</h4>
                            <p style="margin: 0; line-height: 1.6; word-wrap: break-word;">${record.feedback_manager}</p>
                        </div>
                    ` : ''}
                </div>
            `;

            Swal.fire({
                title: 'Informações Detalhadas',
                html: popupContent,
                width: '80%',
                maxWidth: '800px',
                showCloseButton: true,
                showConfirmButton: true,
                confirmButtonText: 'Fechar',
                confirmButtonColor: '#0056b3',
                customClass: {
                    popup: 'problem-details-popup',
                    content: 'problem-details-content'
                }
            });
        }

        var page_num = 1
        let buttons_paginator = document.querySelectorAll('.button-paginator')
        var total_pages
        

        buttons_paginator.forEach(button=>{
            button.addEventListener('click', (e)=>{
                if(e.target.id == "next" && page_num <= total_pages){
                    page_num += 1
                }
                else if(e.target.id == "last" && page_num > 1){
                    page_num -= 1
                }
                applyFiltersAndSort()
            })
            
        })

        const buttons={
                elements: document.querySelector("#paginate #num_pages"),
                
                create(number){
                    const button = document.createElement("div")
                    button.innerHTML = number
                    button.className='page-item'

                    if(page_num == number){
                        button.classList.add("active")
                    }

                    buttons.elements.appendChild(button)
                },
                update(){
                    buttons.elements.innerHTML = ''
                    const {maxLeft, maxRight} = buttons.calculateMaxVisible()
                    
                    for(let page = maxLeft; page <= maxRight; page++){
                        buttons.create(page)
                    }

                },
                calculateMaxVisible(){
                    const maxVisibleButtons = 3
                    let maxLeft = (page_num - Math.floor(maxVisibleButtons/2))
                    let maxRight = (page_num + Math.floor(maxVisibleButtons/2))
                    
                    if(maxLeft < 1){
                        maxLeft = 1
                        maxRight = maxVisibleButtons
                    }
                    if(maxRight > total_pages){
                        maxLeft = total_pages - (maxVisibleButtons - 1)
                        maxRight = total_pages
                        if(maxLeft < 1){
                            maxLeft = 1
                        }
                    }
                    return {maxLeft, maxRight}
                }
            }

        function paginate(hasPrev, hasNext){
            const buttonPrev = document.getElementById("last")
            const buttonNext = document.getElementById("next")
            if(!hasPrev && hasNext){   
                buttonPrev.style.visibility = 'hidden'
                buttonNext.style.visibility = 'visible'
            }
            else if(!hasNext && hasPrev){
                buttonPrev.style.visibility = 'visible'
                buttonNext.style.visibility = 'hidden'
            }
            else if(!hasNext && !hasPrev){
                buttonPrev.style.visibility = 'hidden'
                buttonNext.style.visibility = 'hidden'
            }
            else{
                buttonPrev.style.visibility = 'visible'
                buttonNext.style.visibility = 'visible'
            }
            buttons.update()
        }

        function isValidDate(input) {
            // Verifica o formato com regex: dd/mm/yyyy
            const regex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
            const match = input.match(regex);

            if (!match) return false;

            const day = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const year = parseInt(match[3], 10);

            // Valida mês de 1 a 12
            if (month < 1 || month > 12) return false;

            // Cria a data com JS (os meses são de 0 a 11)
            const date = new Date(year, month - 1, day);

            // Verifica se o dia, mês e ano conferem
            return (
                date.getFullYear() === year &&
                date.getMonth() === month - 1 &&
                date.getDate() === day
            );
        }

        const table = document.getElementById("data-table");
        if (!table) {
            console.error("Erro: Tabela com ID \"data-table\" não encontrada.");
            return;
        }
        const tableBody = document.getElementById("table-body");
        if (!tableBody) {
            console.error("Erro: Corpo da tabela com ID \"table-body\" não encontrado.");
            return;
        }
        
        const headers = Array.from(table.querySelectorAll("thead th[data-column]")); 
        //console.log("Cabeçalhos encontrados no DOM:", headers.map(h => h.getAttribute("data-column")));

        const headerData = headers
            .map((header) => ({
                element: header,
                columnName: header.getAttribute("data-column"),
                filterBox: header.querySelector(".filter-box"),
                isDateColumn: ["data", "deadline", "finished"].includes(
                    header.getAttribute("data-column")
                ),
                isTextAreaColumn: ["feedback_technical", "feedback_manager"].includes(
                    header.getAttribute("data-column")
                ),
            }))
            .filter((h) => h.columnName);

        // console.log("HeaderData processado:", headerData.map(h => ({ col: h.columnName, hasFilterBox: !!h.filterBox })));

        let openFilterBox = null;
        let currentFilters = {}; 
        let currentSort = { column: "data", direction: "asc" };
        let currentFilterOptions = {}; // Armazena as opções de filtro recebidas do backend
        const CSRF_TOKEN = getCookie("csrftoken");

        // --- Funções Auxiliares --- 
        function getCookie(name) { 
             if (document.cookie && document.cookie !== "") {
                const cookies = document.cookie.split(";");
                for (let i = 0; i < cookies.length; i++) {
                    let cookie = cookies[i].trim();
                    if (cookie.startsWith(name + "=")) {
                        return decodeURIComponent(cookie.substring(name.length + 1));
                    }
                }
            }
            return null;
        }

        function parseDateToISO(dateString) { 
            if (!dateString || typeof dateString !== "string") return dateString;
            const parts = dateString.trim().split("/");
            if (parts.length === 3) {
                const [day, month, year] = parts;
                if (
                    day.length === 2 &&
                    month.length === 2 &&
                    year.length === 4 &&
                    !isNaN(parseInt(day)) &&
                    !isNaN(parseInt(month)) &&
                    !isNaN(parseInt(year))
                ) {
                    return `${year}-${month}-${day}`;
                }
            }
            if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return dateString;
            }
            return dateString;
        }
        
        function formatDateToDisplay(isoDateString) { 
            if (!isoDateString || typeof isoDateString !== "string") return "";
            const parts = isoDateString.split("-");
            if (parts.length === 3) {
                const [year, month, day] = parts;
                if (
                    day.length === 2 &&
                    month.length === 2 &&
                    year.length === 4 &&
                    !isNaN(parseInt(day)) &&
                    !isNaN(parseInt(month)) &&
                    !isNaN(parseInt(year))
                ) {
                    return `${day}/${month}/${year}`;
                }
            }
            return isoDateString;
        }

        // --- NOVA FUNÇÃO: Gerar ID único e válido ---
        function generateUniqueId(prefix, value, index = '') {
            // Remove caracteres especiais e espaços, substitui por underscore
            const sanitizedValue = String(value || 'empty')
                .replace(/[^a-zA-Z0-9]/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '');
            
            // Adiciona timestamp para garantir unicidade
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substr(2, 5);
            
            return `${prefix}_${sanitizedValue}_${index}_${timestamp}_${randomSuffix}`;
        }

        // --- Lógica de UI (Filter Box) --- 
        function positionFilterBox(headerElement, filterBoxElement) { 
            const headerRect = headerElement.getBoundingClientRect();
            const tableRect = table.getBoundingClientRect();
            filterBoxElement.style.top = `${headerRect.bottom - tableRect.top + window.scrollY + 2}px`;
            filterBoxElement.style.display = "block";
            const boxRect = filterBoxElement.getBoundingClientRect();
        }

        // *** FUNÇÃO CORRIGIDA E MELHORADA: Criar a árvore de datas hierárquica com toggles ***
        function createDateTreeHTML(columnName, dateTree, level = 0) {
            let html = '';
            const sortedYears = Object.keys(dateTree).sort((a, b) => parseInt(a) - parseInt(b)); // Ordena anos numericamente

            sortedYears.forEach((year) => {
                const yearId = generateUniqueId(`date_${columnName}_year`, year);
                const yearToggleId = `toggle_${yearId}`;
                const yearContentId = `content_${yearId}`;

                html += `
                <div class="filter-tree-node" data-level="year">
                    <div class="node-header">
                        <span class="toggle-icon" id="${yearToggleId}">▶</span>
                        <input type="checkbox" id="${yearId}" data-filter-option="${columnName}" data-tree-level="year" value="${year}">
                        <label for="${yearId}">${year}</label>
                    </div>
                    <div class="node-content" id="${yearContentId}" style="display: none;">`; // Escondido por padrão

                const sortedMonths = Object.keys(dateTree[year]).sort((a, b) => parseInt(a) - parseInt(b)); // Ordena meses numericamente
                sortedMonths.forEach((month) => {
                    const monthName = new Date(2000, parseInt(month) - 1, 1).toLocaleString('pt-BR', { month: 'long' });
                    const monthId = generateUniqueId(`date_${columnName}_month`, `${year}_${month}`);
                    const monthToggleId = `toggle_${monthId}`;
                    const monthContentId = `content_${monthId}`;

                    html += `
                        <div class="filter-tree-node" data-level="month">
                            <div class="node-header" style="margin-left: 20px;">
                                <span class="toggle-icon" id="${monthToggleId}">▶</span>
                                <input type="checkbox" id="${monthId}" data-filter-option="${columnName}" data-tree-level="month" value="${year}-${month}">
                                <label for="${monthId}">${capitalize(monthName)}</label>
                            </div>
                            <div class="node-content" id="${monthContentId}" style="display: none;">`; // Escondido por padrão

                    const sortedDays = dateTree[year][month].sort((a, b) => parseInt(a) - parseInt(b)); // Ordena dias numericamente
                    sortedDays.forEach((day) => {
                        const dayId = generateUniqueId(`date_${columnName}_day`, `${year}_${month}_${day}`);
                        const fullDateValue = `${year}-${month}-${day}`;
                        html += `
                            <div class="filter-tree-node" data-level="day" style="margin-left: 40px;">
                                <input type="checkbox" id="${dayId}" data-filter-option="${columnName}" data-tree-level="leaf" value="${fullDateValue}">
                                <label for="${dayId}">${day}</label>
                            </div>`;
                    });
                    html += `</div></div>`; // Fecha node-content e filter-tree-node (month)
                });
                html += `</div></div>`; // Fecha node-content e filter-tree-node (year)
            });
            return html;
        }

        // *** FUNÇÃO CORRIGIDA E MELHORADA: Popular a caixa de filtro com IDs únicos e lógica de toggle ***
        function populateFilterBox(filterBoxElement, headerInfo) {
            const columnName = headerInfo.columnName;
            let options = currentFilterOptions[columnName] || (headerInfo.isDateColumn ? {} : []);
            
            // Para filtros não-data, garante que as opções sejam um array e únicas
            if (!headerInfo.isDateColumn) {
                try {
                    options = options.map(option => typeof option === "string" ? option.trim() : option);
                    options = [...new Set(options)].sort(); // Ordena alfabeticamente
                } catch (e) {
                    console.error("Erro ao processar opções de filtro não-data:", e);
                    options = [];
                }
            }

            const isDate = headerInfo.isDateColumn;
            const savedFilter = currentFilters[columnName] || { values: [], isApplied: false };
            
            let optionsHTML = '';
            if (isDate) {
                if (Object.keys(options).length > 0) {
                    optionsHTML = createDateTreeHTML(columnName, options);
                } else {
                    optionsHTML = '<p style="padding: 5px; color: grey;">Nenhuma data disponível.</p>';
                }
            } else {
                if (options.length > 0) {
                    options.forEach((option, index) => {
                        const optionId = generateUniqueId(`filter_${columnName}`, option, index);
                        const isChecked = savedFilter.isApplied && savedFilter.values.includes(option);
                        optionsHTML += `<div class="filter-option">
                                        <input type="checkbox" id="${optionId}" data-filter-option="${columnName}" data-tree-level="leaf" value="${option}" ${isChecked ? 'checked' : ''}>
                                        <label for="${optionId}">${option || '(Vazio)'}</label>
                                      </div>`;
                    });
                } else {
                    optionsHTML = '<p style="padding: 5px; color: grey;">Nenhuma opção disponível.</p>';
                }
            }

            filterBoxElement.innerHTML = `
                <div class="filter-header">
                    <input type="checkbox" id="select-all-${columnName}">
                    <label for="select-all-${columnName}">Selecionar Todos</label>
                </div>
                ${!isDate ? `<input type="text" class="filter-search-input" placeholder="Buscar...">` : ''}
                <div class="filter-options">${optionsHTML}</div>
                <div class="filter-actions">
                    <button class="apply-filter-btn">Aplicar</button>
                    <button class="clear-filter-btn">Limpar</button>
                </div>
            `;

            const selectAllCheckbox = filterBoxElement.querySelector(`#select-all-${columnName}`);
            const searchInput = filterBoxElement.querySelector('.filter-search-input');
            const applyButton = filterBoxElement.querySelector('.apply-filter-btn');
            const clearButton = filterBoxElement.querySelector('.clear-filter-btn');
            const optionCheckboxes = filterBoxElement.querySelectorAll('input[type="checkbox"][data-filter-option]');

            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    const isChecked = this.checked;
                    optionCheckboxes.forEach(checkbox => {
                        checkbox.checked = isChecked;
                    });
                });
            }

            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase();
                    const filterOptions = filterBoxElement.querySelectorAll('.filter-option');
                    
                    filterOptions.forEach(option => {
                        const label = option.querySelector('label');
                        if (label) {
                            const text = label.textContent.toLowerCase();
                            option.style.display = text.includes(searchTerm) ? 'block' : 'none';
                        }
                    });
                });
            }

            if (applyButton) {
                applyButton.addEventListener('click', function() {
                    const selectedValues = [];
                    optionCheckboxes.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedValues.push(checkbox.value);
                        }
                    });

                    currentFilters[columnName] = {
                        values: selectedValues,
                        isApplied: selectedValues.length > 0
                    };

                    applyFiltersAndSort(true);
                });
            }

            if (clearButton) {
                clearButton.addEventListener('click', function() {
                    currentFilters[columnName] = { values: [], isApplied: false };
                    applyFiltersAndSort(true);
                });
            }

            if (isDate) {
                addDateHierarchyToggle(filterBoxElement, columnName);
            }
        }

        // *** NOVA FUNÇÃO: Adicionar funcionalidade de toggle hierárquico para datas e sincronização de checkboxes ***
        function addDateHierarchyToggle(filterBoxElement, columnName) {
            const toggleIcons = filterBoxElement.querySelectorAll('.toggle-icon');
            
            toggleIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    const contentId = `content_${this.id.replace('toggle_', '')}`;
                    const contentElement = filterBoxElement.querySelector(`#${contentId}`);
                    if (contentElement) {
                        if (contentElement.style.display === 'none') {
                            contentElement.style.display = 'block';
                            this.textContent = '▼'; // Seta para baixo
                        } else {
                            contentElement.style.display = 'none';
                            this.textContent = '▶'; // Seta para a direita
                        }
                    }
                });
            });

            // Sincronização de checkboxes
            filterBoxElement.addEventListener('change', function(event) {
                const target = event.target;
                if (target.type === 'checkbox' && target.dataset.filterOption === columnName) {
                    const level = target.dataset.treeLevel;
                    const value = target.value;
                    const isChecked = target.checked;

                    if (level === 'year') {
                        // Se um ano é marcado/desmarcado, afeta todos os meses e dias abaixo dele
                        filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${value}-"], input[data-tree-level="leaf"][value^="${value}-"]`).forEach(checkbox => {
                            checkbox.checked = isChecked;
                        });
                    } else if (level === 'month') {
                        // Se um mês é marcado/desmarcado, afeta todos os dias abaixo dele
                        filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${value}-"]`).forEach(checkbox => {
                            checkbox.checked = isChecked;
                        });

                        // Verifica o estado do ano pai
                        const year = value.split('-')[0];
                        const yearCheckbox = filterBoxElement.querySelector(`input[data-tree-level="year"][value="${year}"]`);
                        if (yearCheckbox) {
                            const allMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]`);
                            const checkedMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]:checked`);
                            yearCheckbox.checked = allMonthsOfYear.length === checkedMonthsOfYear.length;
                        }
                    } else if (level === 'leaf') {
                        // Se um dia é marcado/desmarcado, verifica o estado do mês pai
                        const yearMonth = value.substring(0, value.lastIndexOf('-')); // Ex: "2023-01"
                        const monthCheckbox = filterBoxElement.querySelector(`input[data-tree-level="month"][value="${yearMonth}"]`);
                        if (monthCheckbox) {
                            const allDaysOfMonth = filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${yearMonth}-"]`);
                            const checkedDaysOfMonth = filterBoxElement.querySelectorAll(`input[data-tree-level="leaf"][value^="${yearMonth}-"]:checked`);
                            monthCheckbox.checked = allDaysOfMonth.length === checkedDaysOfMonth.length;
                        }

                        // E também verifica o estado do ano pai
                        const year = value.split('-')[0];
                        const yearCheckbox = filterBoxElement.querySelector(`input[data-tree-level="year"][value="${year}"]`);
                        if (yearCheckbox) {
                            const allMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]`);
                            const checkedMonthsOfYear = filterBoxElement.querySelectorAll(`input[data-tree-level="month"][value^="${year}-"]:checked`);
                            yearCheckbox.checked = allMonthsOfYear.length === checkedMonthsOfYear.length;
                        }
                    }
                }
            });
        }

        // --- Lógica de Filtragem e Ordenação ---
        function applyFiltersAndSort(closeBox = false) {
                // 1. Preparar dados de filtro
                const filterData = {
                    filters: {},
                    sort: currentSort,
                    page: page_num
                };

                // 2. Processar filtros ativos
                Object.keys(currentFilters).forEach(columnName => {
                    const filter = currentFilters[columnName];
                    if (filter.isApplied && filter.values.length > 0) {
                        const headerInfo = headerData.find(h => h.columnName === columnName);
                        
                        if (headerInfo?.isDateColumn) {
                            // Para datas, converter para ISO
                            filterData.filters[columnName] = filter.values.map(parseDateToISO);
                        } else {
                            filterData.filters[columnName] = filter.values;
                        }
                    }
                });

                // 3. Enviar para o backend
                fetch("{% url 'filter_data' %}", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": CSRF_TOKEN,
                    },
                    body: JSON.stringify(filterData),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) throw new Error(data.error);
                    
                    currentFilterOptions = data.filter_options || {};
                    updateTable(data.records);
                    
                    total_pages = data.num_pages;
                    paginate(data.has_previous, data.has_next);

                    // --- INÍCIO DA NOVA LÓGICA PARA FEEDBACK VISUAL DE FILTRO ---
                    // Remove a classe 'filtered' de todos os cabeçalhos primeiro
                    headers.forEach(header => {
                        header.classList.remove('filtered');
                    });

                    // Adiciona a classe 'filtered' aos cabeçalhos com filtros ativos
                    Object.keys(currentFilters).forEach(columnName => {
                        const filter = currentFilters[columnName];
                        if (filter.isApplied && filter.values.length > 0) {
                            const headerInfo = headerData.find(h => h.columnName === columnName);
                            if (headerInfo && headerInfo.element) {
                                headerInfo.element.classList.add('filtered');
                            }
                        }
                    });
                    // --- FIM DA NOVA LÓGICA PARA FEEDBACK VISUAL DE FILTRO ---

                })
                .catch(error => {
                    console.error("Erro ao filtrar:", error);
                    Swal.fire("Erro", "Ocorreu um erro ao aplicar os filtros.", "error");
                });

                // 4. Fechar a caixa de filtro se necessário
                if (closeBox && openFilterBox) {
                    openFilterBox.style.display = "none";
                    openFilterBox = null;
                }
            }

        /**
        * Atualiza o corpo da tabela.
        */
        function updateTable(records) { 
            tableBody.innerHTML = ""; 
            if (!records || records.length === 0) {
                const colspan = table.querySelectorAll("thead th[data-column]").length;
                const noResultsRow = tableBody.insertRow();
                const cell = noResultsRow.insertCell();
                
                cell.colSpan = colspan > 0 ? colspan : 1; 
                cell.textContent = "Nenhum registro encontrado.";
                cell.style.textAlign = "center";
                return;
            }
            const visibleColumns = Array.from(table.querySelectorAll("thead th[data-column]")).map(th => th.getAttribute('data-column'));
            //console.log("Colunas visíveis para renderizar linhas:", visibleColumns); 
            let has_full_permission = '{{has_full_permission}}'

            const UTCtime = new Date()
            var today = new Date(`${UTCtime.getUTCMonth()+1}/${UTCtime.getUTCDate()}/${UTCtime.getUTCFullYear()}`)
            
            records.forEach((record) => {
                const row = tableBody.insertRow();
                visibleColumns.forEach(columnName => {
                    const cell = row.insertCell();
                    cell.setAttribute("data-column", columnName);
                    cell.setAttribute("data-id", record.id)

                    let value = record[columnName]; 
                    const headerInfo = headerData.find(h => h.columnName === columnName);
                    // Formata data apenas se for uma coluna de data e tiver valor
                    if (headerInfo?.isDateColumn) { 
                        if(value){
                            value = formatDateToDisplay(value);
                        }
                        else{
                            if(columnName == 'finished'){
                                value = "Não finalizado"
                            }
                            else{
                                value = 'Não definido'
                            }
                        }
                    }
                    
                    // *** MODIFICAÇÃO PRINCIPAL: Adicionar botão para Problem Detected ***
                    if(columnName == 'problem_detected'){
                        cell.classList.add("no-cursor")
                        
                        // Criar container para o conteúdo
                        const container = document.createElement('div');
                        container.style.display = 'flex';
                        container.style.alignItems = 'center';
                        container.style.justifyContent = 'center';
                        
                        
                        // Botão para abrir detalhes
                        const detailsButton = document.createElement('button');
                        detailsButton.innerHTML = '👁️ Ver Detalhes';
                        detailsButton.style.cssText = `
                            background: linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%);
                            color: white;
                            border: none;
                            padding: 6px 12px;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 0.8rem;
                            font-weight: 600
                        `;
                        
                        detailsButton.addEventListener('mouseenter', function() {
                            this.style.background = 'linear-gradient(135deg, #3a7bc8 0%, #0056b3 100%)';
                            this.style.transform = 'translateY(-1px)';
                            this.style.boxShadow = '0 4px 12px rgba(0, 86, 179, 0.3)';
                        });
                        
                        detailsButton.addEventListener('mouseleave', function() {
                            this.style.background = 'linear-gradient(135deg, #0056b3 0%, #3a7bc8 100%)';
                            this.style.transform = 'translateY(0)';
                            this.style.boxShadow = 'none';
                        });
                        
                        detailsButton.addEventListener('click', function(e) {
                            e.stopPropagation();
                            showProblemDetails(record);
                        });
                        
                        container.appendChild(detailsButton);
                        cell.appendChild(container);
                        
                        // Manter funcionalidade de duplo clique para copiar
                        cell.addEventListener('dblclick', (e)=>{
                            navigator.clipboard.writeText(record.problem_detected || 'Nenhum problema detectado')
                            Swal.fire({
                                title:"Texto copiado",
                                text: 'Problema copiado para área de transferência',
                                showCloseButton: true,
                                icon:'success'
                            })
                        })
                    }
                    

                    else if (columnName == 'status'){
                        const data_deadline = record['deadline'] ? new Date(record['deadline'].split('/').reverse().join('-')) : null
                        const data_finished = record['finished'] ? new Date(record['finished'].split('/').reverse().join('-')) : null
                        
                        

                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('field-container')
                        let statu = document.querySelector(`#${columnName}${record.id}`)
                        statu.setAttribute('data-initial-value', value)

                        let valor_inicial = statu.getAttribute('data-initial-value')

                        if(valor_inicial != 'Concluído'){
                            if(data_finished){
                                statu.value = 'Concluído'
                                saveField(statu)

                            }
                            else if(!data_deadline && valor_inicial != 'Requisitado'){
                                statu.value = 'Requisitado'
                                saveField(statu)
                                record['finished'].disabled = true

                            }
                            else if(data_deadline && today  < data_deadline && valor_inicial != 'Em progresso'){
                                console.log(valor_inicial);
                                statu.value = 'Em progresso'
                                saveField(statu)

                            }
                            else if(data_deadline && today  > data_deadline && valor_inicial == 'Em progresso'){
                                statu.value = 'Atrasado'
                                saveField(statu)

                            }
                            else if(data_deadline && today  > data_deadline && valor_inicial == 'Requisitado'){
                                statu.value = 'Atrasado'
                                saveField(statu)

                            }
                        }
                        
                    }

                    else if( (columnName == 'deadline' && '{{has_full_permission}}' === 'True') || columnName == 'finished' ) {
                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('editable-field-container')
                        cell.classList.add('date-input-container')  
                        // cell.title = "Clique duas vezes para copiar o texto"
                        // Input de texto para a data formatada
                        const textInput = document.createElement('input');
                        textInput.type = 'text';
                        textInput.placeholder = 'DD/MM/AAAA';
                        textInput.classList.add('date-text-input')
                        
                        cell.addEventListener('dblclick', (e)=>{
                            navigator.clipboard.writeText(e.target.getAttribute('data-initial-value'))
                            textInput.blur()
                            Swal.fire({
                                title:"Texto copiado",
                                text: 'Data copiada para área de transferência',
                                showCloseButton: true,
                                icon:'success'
                            })
                        })

                        if(columnName == "finished" && !record['deadline']){
                            textInput.disabled = true
                            
                        }

                        textInput.placeholder = value;
                        textInput.setAttribute('data-initial-value', value)
                        let [initial_day, initial_month, initial_year] = value.split("/").map(Number)
                        let initial_date = new Date(`${initial_month+1}/${initial_day}/ ${initial_year}`)
                        
                        // Adiciona os elementos ao container
                        cell.appendChild(textInput);
                        
                        // Configura os eventos
                        textInput.addEventListener('blur', function(e){
                            e.target.classList.remove("erro")
                            e.target.classList.remove("success")
                        })

                        textInput.addEventListener('input', function(e) {
                            let value = e.target.value.replace(/\D/g, '');
                            
                            // Formatação automática: DD/MM/AAAA
                            if (value.length > 2) value = value.substring(0, 2) + '/' + value.substring(2);
                            if (value.length > 5) value = value.substring(0, 5) + '/' + value.substring(5, 9);

                            
                            
                            e.target.value = value;
                            if(columnName == 'finished'){
                                if(value.split('/').length !=3){
                                    e.target.classList.add("erro")
                                    e.target.classList.remove("success")
                                }
                                else{
                                    
                                    var deadline_data = new Date(record['deadline'])
                                    var input_data = new Date(`${value.split('/')[1]}/${value.split('/')[0]}/${value.split('/')[2]}`)
                                    
                                    if(input_data < deadline_data){
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    }
                                    else if(value.split('/')[2].length == 4 && isValidDate(value)){
                                        e.target.classList.remove("erro")
                                        e.target.classList.add("success")
                                        atualizarDados(e)
                                    }
                                    else{
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    }
                                }
                            }else if(columnName == 'deadline'){
                                if(value.split('/').length !=3){
                                    e.target.classList.add("erro")
                                    e.target.classList.remove("success")
                                }
                                else{
                                    var finished = new Date(record['finished'])
                                    var data = new Date(record['data'])
                                    var input_data = new Date(`${value.split('/')[1]}/${value.split('/')[0]}/${value.split('/')[2]}`)
                                    
                                    if(input_data < data){
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")

                                    }
                                    else if(finished && input_data > finished){
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")

                                    }
                                    else if(value.split('/')[2].length == 4 && isValidDate(value)){
                                        e.target.classList.remove("erro")
                                        e.target.classList.add("success")
                                        atualizarDados(e)
                                    }
                                    else{
                                        e.target.classList.add("erro")
                                        e.target.classList.remove("success")
                                    }
                                }
                            }
                            
                        })
                        if(textInput.classList[0] == 'date-text-input'){
                            let teste = flatpickr('.date-text-input', {'allowInput':true, 'dateFormat':'d/m/Y', 'minDate':'today'})
                        }
                    }
                    else if((columnName == 'responsible' && '{{has_full_permission}}' === 'True')){
                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('editable-field-container')
                        cell.classList.add('date-input-container')

                        let input = document.createElement('input')
                            input.setAttribute('data-initial-value', value)
                            input.rows = 5
                            input.cols = 20
                            input.placeholder = value
                            // input.title="Clique duas vezes para copiar o texto"
                            input.id = `${columnName}${record.id}`
                            input.addEventListener('input', (e)=>atualizarDados(e))
                            input.addEventListener('dblclick', (e)=>{
                            navigator.clipboard.writeText(e.target.getAttribute('data-initial-value'))
                            Swal.fire({
                                title:"Texto copiado",
                                text: 'Feedback copiado para área de transferência',
                                showCloseButton: true,
                                icon:'success'
                            })
                        })
                        cell.appendChild(input)
                    }
                    
                    else if(headerInfo.isTextAreaColumn){
                        cell.id = `${columnName}${record.id}`
                        cell.classList.add('editable-field-container')
                        cell.classList.add('date-input-container')

                        let textArea = document.createElement('textarea')
                        textArea.setAttribute('data-initial-value', value)
                        textArea.rows = 5
                        textArea.cols = 20
                        textArea.placeholder = value
                        // textArea.title="Clique duas vezes para copiar o texto"
                        textArea.id = `${columnName}${record.id}`
                        textArea.addEventListener('input', (e)=>atualizarDados(e))
                        textArea.addEventListener('dblclick', (e)=>{
                            navigator.clipboard.writeText(e.target.getAttribute('data-initial-value'))
                            Swal.fire({
                                title:"Texto copiado",
                                text: 'Feedback copiado para área de transferência',
                                showCloseButton: true,
                                icon:'success'
                            })
                        })
                        cell.appendChild(textArea)
                    }
                    else{
                        cell.textContent = (value !== null && value !== undefined) ? value : ""; 
                    }
                    
                });
            });
        }

        // --- Inicialização ---
        //console.log("Inicializando event listeners para cabeçalhos...");
        headerData.forEach((headerInfo) => {
            const { element: headerElement, filterBox: filterBoxElement, columnName } = headerInfo;
            if (filterBoxElement) { 
                //console.log(`Adicionando listener de clique para ${columnName}`);
                filterBoxElement.id = `filter-box-${columnName}`;
                headerElement.addEventListener("click", (event) => {
                    //console.log(`Clique detectado no cabeçalho ${columnName}`);
                    if (event.target.closest(".filter-box")) {
                        //console.log("Clique dentro da filter-box, ignorando.");
                        return; 
                    }
                    if (openFilterBox && openFilterBox !== filterBoxElement) {
                        //console.log("Fechando outra filter-box aberta.");
                        openFilterBox.style.display = "none";
                    }
                    const isCurrentlyOpen = filterBoxElement.style.display === "block";
                    if (isCurrentlyOpen) {
                        //console.log(`Fechando filter-box para ${columnName}`);
                        filterBoxElement.style.display = "none";
                        openFilterBox = null;
                    } else {
                        //console.log(`Abrindo filter-box para ${columnName}`);
                        // *** AGORA POPULA COM OPÇÕES DINÂMICAS ***
                        populateFilterBox(filterBoxElement, headerInfo); 
                        
                        filterBoxElement.style.display = "block";
                        positionFilterBox(headerElement, filterBoxElement);
                        openFilterBox = filterBoxElement;
                        const searchInput = filterBoxElement.querySelector(".filter-search-input");
                        if (searchInput) searchInput.focus();
                    }
                    event.stopPropagation(); 
                });
            } else {
                 //console.log(`Sem filter-box para ${columnName}, listener não adicionado.`);
            }
        });

        // Listener para fechar a caixa ao clicar fora
        document.addEventListener("click", (event) => {
            if (
                openFilterBox &&
                !event.target.closest("th") && 
                !openFilterBox.contains(event.target) 
            ) {
                //console.log("Clique fora, fechando filter-box.");
                openFilterBox.style.display = "none";
                openFilterBox = null;
            }
        });
        
        // Chama para carregar dados iniciais via AJAX
        //console.log("Chamando applyFiltersAndSort para carregamento inicial...");
        applyFiltersAndSort(false); 

        let typingTimer;
        const doneTypingInterval = 2000;

        function atualizarDados(e){   
            clearTimeout(typingTimer);   
            let dado = e.target ? e.target : e
                
            let valor_inicial = dado.getAttribute('data-initial-value')
            let valor_input = dado.value
            if(valor_input !== valor_inicial) {
                dado.classList.add('pending-save')
                typingTimer = setTimeout(() => saveField(dado), doneTypingInterval);
            }
            
        }
        function saveField(inputElement) {
            const container = inputElement.closest('.editable-field-container') ? inputElement.closest('.editable-field-container') : inputElement.closest('.field-container');
            const reportID = container.getAttribute('data-id');
            const fieldName = container.getAttribute('data-column');
            const newValue = inputElement.value
            
            
            fetch('{% url "update_ocorrencia/" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'  // Envia o CSRF token no cabeçalho
                },
                body: JSON.stringify({
                    id: reportID,
                    field: fieldName,
                    value: newValue,
                    page_num: page_num
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Erro na requisição');
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    inputElement.classList.remove('pending-save', 'saving');
                    inputElement.setAttribute('data-initial-value', newValue);
                    
                    // Atualiza o display se necessário
                    if (data.display_value) {
                        inputElement.value = data.display_value;
                        inputElement.setAttribute('placeholder', data.display_value);
                        inputElement.dataset.initialValue = data.display_value;
                    }
                }
                // location.reload();
                page_num = data.page_num
                setTimeout(() => inputElement.classList.remove('success'), 5000);
            })
            .catch(error => {
                console.error('Erro:', error.message);
                inputElement.classList.remove('saving');
                inputElement.classList.add('error');
                setTimeout(() => inputElement.classList.remove('error'), 5000);
            });
    

        }
    

    });
</script>

</body>
</html>
